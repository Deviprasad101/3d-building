<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>DeckGL Test</title>

    <!-- Deck.gl -->
    <script src="https://unpkg.com/deck.gl@8.9.36/dist.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <!-- Mapbox -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <div id="sidebar"
        style="position: absolute; top: 10px; left: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; font-family: sans-serif; max-height: 95vh; overflow-y: auto;">

        <!-- 1. Height Legend (Checkboxes) -->
        <div id="legend"
            style="background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2); min-width: 150px;">
            <h4 style="margin: 0 0 10px 0; border-bottom: 1px solid #ccc; padding-bottom: 5px;">Height Filters</h4>

            <!-- 0-10m -->
            <label style="display: flex; align-items: center; margin-bottom: 5px; cursor: pointer;">
                <input type="checkbox" checked class="filter-checkbox" data-min="0" data-max="10"
                    style="margin-right: 8px;">
                <span
                    style="display:inline-block;width:15px;height:15px;background-color:rgb(12, 227, 12);margin-right:8px;border:1px solid #ccc;"></span>
                0 - 10m
            </label>

            <!-- 10-20m -->
            <label style="display: flex; align-items: center; margin-bottom: 5px; cursor: pointer;">
                <input type="checkbox" checked class="filter-checkbox" data-min="10" data-max="20"
                    style="margin-right: 8px;">
                <span
                    style="display:inline-block;width:15px;height:15px;background-color:rgb(15, 15, 208);margin-right:8px;border:1px solid #ccc;"></span>
                10 - 20m
            </label>

            <!-- 20-30m -->
            <label style="display: flex; align-items: center; margin-bottom: 5px; cursor: pointer;">
                <input type="checkbox" checked class="filter-checkbox" data-min="20" data-max="30"
                    style="margin-right: 8px;">
                <span
                    style="display:inline-block;width:15px;height:15px;background-color:rgb(181, 102, 115);margin-right:8px;border:1px solid #ccc;"></span>
                20 - 30m
            </label>

            <!-- 30-50m -->
            <label style="display: flex; align-items: center; margin-bottom: 5px; cursor: pointer;">
                <input type="checkbox" checked class="filter-checkbox" data-min="30" data-max="50"
                    style="margin-right: 8px;">
                <span
                    style="display:inline-block;width:15px;height:15px;background-color:rgb(224, 163, 51);margin-right:8px;border:1px solid #ccc;"></span>
                30 - 50m
            </label>

            <!-- 50m+ -->
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" checked class="filter-checkbox" data-min="50" data-max="9999"
                    style="margin-right: 8px;">
                <span
                    style="display:inline-block;width:15px;height:15px;background-color:rgb(255, 0, 0);margin-right:8px;border:1px solid #ccc;"></span>
                50m +
            </label>
        </div>

        <!-- 2. Search Building -->
        <div id="search-container"
            style="background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2);">
            <h4 style="margin: 0 0 10px 0; border-bottom: 1px solid #ccc; padding-bottom: 5px;">Search Building</h4>
            <div style="display: flex; margin-bottom: 10px;">
                <input type="text" id="search-input" placeholder="Enter Number"
                    style="padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-right: 5px; width: 100px;">
                <button id="search-btn"
                    style="padding: 5px 10px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">Go</button>
            </div>
            <div id="search-result" style="display: none;">
                <div><strong>Height:</strong> <span id="search-height">-</span> m</div>
                <div><strong>Roof Area:</strong> <span id="search-area">-</span> m¬≤</div>
            </div>
        </div>

        <!-- 3. Road Distance (OSRM) -->
        <div style="background:white; padding:10px; border-radius:5px; box-shadow:0 0 10px rgba(0,0,0,0.2);">

            <h4 style="margin:0 0 8px 0; border-bottom:1px solid #ccc;">
                Road Distance
            </h4>

            <input id="road-a" placeholder="Building A" style="width:90px; margin-bottom:5px;"><br>
            <input id="road-b" placeholder="Building B" style="width:90px; margin-bottom:5px;"><br>

            <button id="road-btn">Calculate</button>

            <div id="road-output" style="margin-top:8px; font-size:13px;"></div>
        </div>

        <!-- 4. Basemap -->
        <div id="basemap-container"
            style="background:white; padding:10px; border-radius:5px; box-shadow:0 0 10px rgba(0,0,0,0.2);">
            <h4 style="margin:0 0 8px 0; border-bottom:1px solid #ccc;">Basemap</h4>
            <select id="basemap-select" style="padding:5px; border-radius:3px; border:1px solid #ccc; width:160px;">
                <option value="satellite">Satellite</option>
                <option value="streets">Streets</option>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
            </select>
        </div>

    </div>

    <div id="tooltip"
        style="position: absolute; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2); pointer-events: none; display: none; z-index: 1000; font-family: sans-serif; min-width: 150px; transform: translate(10px, 10px);">
        <h4 style="margin: 0 0 5px 0; border-bottom: 1px solid #ccc; padding-bottom: 5px;">Building Info</h4>
        <div><strong>No:</strong> <span id="number-value">-</span></div>
        <div><strong>Height:</strong> <span id="height-value">-</span> m</div>
        <div><strong>Roof Area:</strong> <span id="area-value">-</span> m¬≤</div>
    </div>

    <div id="map"></div>

    <script>
        fetch("buildings.geojson")
            .then(r => r.json())
            .then(data => {

                // 2Ô∏è‚É£ Define Basemap Configs
                let currentBasemap = "satellite";

                // 2Ô∏è‚É£ Define Basemap Configs (Token-Free)
                const basemaps = {
                    satellite: {
                        id: 'satellite-layer',
                        data: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                        attribution: 'Esri'
                    },
                    streets: {
                        id: 'streets-layer',
                        data: 'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        attribution: 'OSM'
                    },
                    light: {
                        id: 'light-layer',
                        data: 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                        attribution: 'CartoDB'
                    },
                    dark: {
                        id: 'dark-layer',
                        data: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
                        attribution: 'CartoDB'
                    }
                };

                const firstFeature = data.features[0];
                let lng, lat;

                if (firstFeature.geometry.type === "Polygon") {
                    [lng, lat] = firstFeature.geometry.coordinates[0][0];
                } else if (firstFeature.geometry.type === "MultiPolygon") {
                    [lng, lat] = firstFeature.geometry.coordinates[0][0][0];
                }

                function getHeightColor(h) {
                    if (!h) return [200, 200, 200, 180]; // Grey for no data
                    if (h <= 10) return [0, 255, 0, 180]; // Green
                    if (h <= 20) return [0, 0, 255, 180]; // Blue
                    if (h <= 30) return [255, 192, 203, 180]; // Pink
                    if (h <= 50) return [255, 165, 0, 180]; // Orange
                    return [255, 0, 0, 180]; // Red
                }

                // Calculate centroids and create data for TextLayer
                // Calculate centroids and create data for TextLayer
                const textData = data.features.map((feature, index) => {
                    const number = (index + 1).toString();
                    feature.properties.number = number; // Add to properties for tooltip

                    const centroid = turf.centroid(feature);
                    return {
                        position: centroid.geometry.coordinates,
                        text: number,
                        color: [255, 255, 255]
                    };
                });

                let currentViewState = {
                    longitude: lng,
                    latitude: lat,
                    zoom: 16,
                    pitch: 60,
                    bearing: -30
                };
                function getHighlightLayer() {
                    if (!selectedBuildingNumber) return null;

                    const feature = data.features.find(
                        f => f.properties.number === selectedBuildingNumber
                    );

                    if (!feature) return null;

                    return new deck.GeoJsonLayer({
                        id: 'selected-building-highlight',
                        data: feature,
                        extruded: true,
                        wireframe: false,

                        // üî• Make it stand out ABOVE other buildings
                        getElevation: f => (f.properties.height_m ?? 20) + 15,

                        // üî• DARK semi-transparent fill
                        getFillColor: [0, 0, 0, 160],   // dark black overlay

                        // üî• STRONG bright outline
                        getLineColor: [255, 255, 0, 255], // bright yellow
                        lineWidthUnits: 'pixels',
                        getLineWidth: 6,

                        pickable: false
                    });
                }



                let selectedBuildingNumber = null;

                let roadRouteGeoJSON = null;

                // Config for filtering
                const heightFilters = {
                    ranges: [
                        { min: 0, max: 10, enabled: true },
                        { min: 10, max: 20, enabled: true },
                        { min: 20, max: 30, enabled: true },
                        { min: 30, max: 50, enabled: true },
                        { min: 50, max: 9999, enabled: true }
                    ]
                };

                async function calculateRoadDistance(numA, numB) {
                    const f1 = data.features.find(f => f.properties.number === numA);
                    const f2 = data.features.find(f => f.properties.number === numB);

                    if (!f1 || !f2) {
                        alert("One or both buildings not found");
                        return;
                    }

                    const c1 = turf.centroid(f1).geometry.coordinates;
                    const c2 = turf.centroid(f2).geometry.coordinates;

                    const url =
                        `https://router.project-osrm.org/route/v1/driving/` +
                        `${c1[0]},${c1[1]};${c2[0]},${c2[1]}` +
                        `?overview=full&geometries=geojson`;

                    const res = await fetch(url);
                    const json = await res.json();

                    if (!json.routes || !json.routes.length) {
                        alert("Routing failed");
                        return;
                    }

                    const route = json.routes[0];

                    // Distance in meters
                    document.getElementById('road-output').innerHTML =
                        `<b>Road Distance:</b><br>${route.distance.toFixed(2)} m<br>${(route.distance / 1000).toFixed(2)} km`;

                    roadRouteGeoJSON = {
                        type: "Feature",
                        geometry: route.geometry
                    };

                    // Fly to route center
                    const mid = turf.centroid(roadRouteGeoJSON).geometry.coordinates;

                    currentViewState = {
                        ...currentViewState,
                        longitude: mid[0],
                        latitude: mid[1],
                        zoom: 16,
                        transitionDuration: 1200,
                        transitionInterpolator: new deck.FlyToInterpolator()
                    };

                    deckgl.setProps({
                        viewState: currentViewState,
                        layers: getLayers()
                    });
                }

                // 3Ô∏è‚É£ Modify getLayers() to Support Switching & Filtering
                function getLayers() {
                    const layers = [];

                    // Base Map Layer (Token-Free TileLayer)
                    const baseConfig = basemaps[currentBasemap];
                    layers.push(
                        new deck.TileLayer({
                            id: baseConfig.id,
                            data: baseConfig.data,
                            minZoom: 0,
                            maxZoom: 19,
                            tileSize: 256,
                            renderSubLayers: props => {
                                const { bbox: { west, south, east, north } } = props.tile;
                                return new deck.BitmapLayer(props, {
                                    data: null,
                                    image: props.data,
                                    bounds: [west, south, east, north]
                                });
                            }
                        })
                    );

                    // Filter Logic: CHECKBOXES
                    const filteredFeatures = data.features.filter(f => {
                        const h = f.properties.height_m ?? 0;
                        // Returns true if height matches ANY enabled range
                        return heightFilters.ranges.some(range =>
                            range.enabled && h >= range.min && h < range.max
                        );
                    });

                    // Buildings layer
                    layers.push(
                        new deck.GeoJsonLayer({
                            id: "buildings",
                            data: {
                                type: "FeatureCollection",
                                features: filteredFeatures
                            },
                            extruded: true,
                            wireframe: true,
                            getElevation: f => f.properties.height_m ?? 20,
                            getFillColor: f => getHeightColor(f.properties.height_m),
                            pickable: true,
                            autoHighlight: true,
                            onHover: info => {
                                const tooltip = document.getElementById('tooltip');
                                if (info.object) {
                                    tooltip.style.display = 'block';
                                    tooltip.style.left = info.x + 'px';
                                    tooltip.style.top = info.y + 'px';
                                    document.getElementById('number-value').innerText =
                                        info.object.properties.number || 'N/A';
                                    document.getElementById('height-value').innerText =
                                        info.object.properties.height_m?.toFixed(2) || 'N/A';
                                    document.getElementById('area-value').innerText =
                                        turf.area(info.object).toFixed(2);
                                } else {
                                    tooltip.style.display = 'none';
                                }
                            }
                        })
                    );
                    // Highlight layer
                    const highlightLayer = getHighlightLayer();
                    if (highlightLayer) layers.push(highlightLayer);



                    if (roadRouteGeoJSON) {
                        layers.push(new deck.GeoJsonLayer({
                            id: 'road-route',
                            data: roadRouteGeoJSON,
                            getLineColor: [0, 0, 0, 255],
                            lineWidthUnits: 'pixels',
                            getLineWidth: 4,
                            pickable: false
                        }));
                    }

                    return layers;
                }

                window.deckgl = new deck.DeckGL({
                    container: "map",
                    // map: mapboxgl, // Removed dependency
                    // mapboxAccessToken: "YOUR_MAPBOX_TOKEN_HERE", // Removed dependency
                    // mapStyle: basemaps[currentBasemap].mapStyle, // Removed dependency
                    viewState: currentViewState,
                    controller: true,
                    onViewStateChange: ({ viewState }) => {
                        currentViewState = viewState;
                        deckgl.setProps({ viewState: currentViewState });
                    },
                    layers: getLayers()
                });

                // 5Ô∏è‚É£ Add Basemap Change Listener
                document.getElementById("basemap-select").addEventListener("change", e => {
                    currentBasemap = e.target.value;

                    deckgl.setProps({
                        layers: getLayers()
                    });
                });

                // Search Functionality
                document.getElementById('search-btn').addEventListener('click', () => {
                    const searchInput = document.getElementById('search-input').value.trim();
                    const resultDiv = document.getElementById('search-result');
                    const heightSpan = document.getElementById('search-height');
                    const areaSpan = document.getElementById('search-area');

                    if (!searchInput) {
                        alert("Please enter a building number.");
                        return;
                    }

                    const feature = data.features.find(f => f.properties.number === searchInput);

                    if (feature) {
                        // Update state
                        selectedBuildingNumber = searchInput;

                        resultDiv.style.display = 'block';

                        // Height
                        const height = feature.properties.height_m;
                        heightSpan.innerText = height ? height.toFixed(2) : 'N/A';

                        // Area
                        try {
                            const area = turf.area(feature);
                            areaSpan.innerText = area ? area.toFixed(2) : 'N/A';
                        } catch (e) {
                            console.error("Area calculation error:", e);
                            areaSpan.innerText = 'Error';
                        }

                        // Fly to building
                        const centroid = turf.centroid(feature).geometry.coordinates;
                        const [flyLng, flyLat] = centroid;

                        currentViewState = {
                            ...currentViewState,
                            longitude: flyLng,
                            latitude: flyLat,
                            zoom: 18,
                            pitch: 65,
                            bearing: -30,
                            transitionDuration: 1500,
                            transitionInterpolator: new deck.FlyToInterpolator()
                        };

                        // Trigger re-render with new layers and view state
                        deckgl.setProps({
                            viewState: currentViewState,
                            layers: getLayers()
                        });

                    } else {
                        // Clear highlight if not found
                        selectedBuildingNumber = null;

                        resultDiv.style.display = 'none';
                        alert("Building not found!");

                        // Re-render to clear highlight
                        deckgl.setProps({ layers: getLayers() });
                    }
                });



                document.getElementById('road-btn').onclick = () => {
                    const a = document.getElementById('road-a').value.trim();
                    const b = document.getElementById('road-b').value.trim();

                    if (!a || !b) {
                        alert("Enter both building numbers");
                        return;
                    }

                    calculateRoadDistance(a, b);
                };

                // Add Checkbox Listeners
                document.querySelectorAll('.filter-checkbox').forEach(cb => {
                    cb.addEventListener('change', (e) => {
                        const min = parseFloat(e.target.dataset.min);
                        const max = parseFloat(e.target.dataset.max);
                        const isChecked = e.target.checked;

                        // Update global config
                        const range = heightFilters.ranges.find(r => r.min === min && r.max === max);
                        if (range) {
                            range.enabled = isChecked;
                        }

                        // Trigger re-render
                        deckgl.setProps({
                            layers: getLayers()
                        });
                    });
                });
            });
    </script>


</body>

</html>